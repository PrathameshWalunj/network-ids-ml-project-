import pefile
import hashlib
import os
import magic
import math
import subprocess
from dotenv import load_dotenv
import requests
import time
import yara
import ssdeep




load_dotenv()      # Load environment variables from .env file

VT_API_KEY = os.getenv('VIRUSTOTAL_API_KEY')
if not VT_API_KEY:
    raise ValueError("VirusTotal API key not found in environment variables")

last_request_time = 0

def rate_limited_request(url, headers):
    global last_request_time
    current_time = time.time()
    if current_time - last_request_time < 15:  # Ensure 15 seconds between requests
        time.sleep(15 - (current_time - last_request_time))
    response = requests.get(url, headers=headers)
    last_request_time = time.time()
    return response




def calculate_hash(file_path):
    """Calculate MD5 and SHA256 hashes of a file."""
    with open(file_path, 'rb') as f:
        data = f.read()
        md5 = hashlib.md5(data).hexdigest()
        sha256 = hashlib.sha256(data).hexdigest()
    return md5, sha256

def get_file_type(file_path):
    """Determine the file type using magic numbers."""
    return magic.from_file(file_path)

def analyze_pe(file_path):
    """Perform basic analysis on PE files."""
    try:
        pe = pefile.PE(file_path)
        pe_info = {
            'Machine': pe.FILE_HEADER.Machine,
            'NumberOfSections': pe.FILE_HEADER.NumberOfSections,
            'TimeDateStamp': pe.FILE_HEADER.TimeDateStamp,
            'Characteristics': pe.FILE_HEADER.Characteristics,
            'EntryPoint': pe.OPTIONAL_HEADER.AddressOfEntryPoint,
            'ImageBase': pe.OPTIONAL_HEADER.ImageBase,
        }
        pe_info['suspicious_imports'] = analyze_imports(pe)
    except pefile.PEFormatError:
        return None
    

def extract_strings(file_path):
    """Extract ASCII and Unicode strings from the file."""
    result = subprocess.run(['strings', file_path], stdout=subprocess.PIPE)
    return result.stdout.decode('utf-8', errors='ignore')

def calculate_entropy(data):
    """Calculate the entropy of the given data."""
    if not data:
        return 0
    entropy = 0
    data_length = len(data)
    for x in range(256):
        p_x = data.count(chr(x)) / data_length
        if p_x > 0:
            entropy += - p_x * math.log2(p_x)
    return entropy

def get_mitre_attack_techniques(file_hash):
    url = f"https://www.virustotal.com/api/v3/files/{file_hash}/behaviour_mitre_trees"
    headers = {"accept": "application/json", "x-apikey": VT_API_KEY}
    response = requests.get(url, headers=headers)
    if response.status_code == 200:
        return response.json()
    else:
        return {"error": f"MITRE ATT&CK API request failed with status code {response.status_code}"}
    

def yara_match(file_path):
    rules_path = os.path.join(os.path.dirname(os.path.dirname(__file__)), 'consolidated_rules.yar')
    rules = yara.compile(filepath=rules_path)
    matches = rules.match(file_path)
    return [match.rule for match in matches]



def get_virustotal_report(file_hash):
    """Get VirusTotal report for a file hash."""
    url = f"https://www.virustotal.com/api/v3/files/{file_hash}"
    headers = {
        "accept": "application/json",
        "x-apikey": VT_API_KEY
    }
    response = requests.get(url, headers=headers)
    if response.status_code == 200:
        return response.json()
    else:
        return {"error": f"API request failed with status code {response.status_code}"}
    

def get_similar_samples(file_hash):
    url = f"https://www.virustotal.com/api/v3/files/{file_hash}/similar_samples"
    headers = {"accept": "application/json", "x-apikey": VT_API_KEY}
    response = rate_limited_request(url, headers)
    if response.status_code == 200:
        return response.json().get('data', [])
    return []

def analyze_imports(pe):
    suspicious_imports = {
        "kernel32.dll": [
        "CreateRemoteThread",
        "VirtualAllocEx",
        "WriteProcessMemory",
        "CreateFileA",
        "OpenProcess",
        "TerminateProcess",
        "SetWindowsHookEx",
        "GetProcAddress",
        "LoadLibraryA",
        "VirtualFree",
    ],
    "advapi32.dll": [
        "RegOpenKeyEx",
        "RegSetValueEx",
        "RegDeleteValue",
        "OpenEvent",
        "CreateEvent",
        "ReportEvent",
        "SetServiceStatus",
        "CreateServiceA",
    ],
    "wininet.dll": [
        "InternetOpen",
        "InternetConnect",
        "HttpOpenRequest",
        "HttpSendRequest",
        "InternetReadFile",
        "InternetWriteFile",
        "InternetCloseHandle",
    ],
    "user32.dll": [
        "FindWindowA",
        "SetWindowsHookEx",
        "SendMessageA",
        "PostMessageA",
        "ShowWindow",
        "MessageBoxA",
    ],
    "shell32.dll": [
        "ShellExecuteA",
        "SHGetFolderPath",
        "SHFileOperation",
    ],
    "ws2_32.dll": [
        "socket",
        "connect",
        "recv",
        "send",
    ],
    "mswsock.dll": [
        "AcceptEx",
        "GetAcceptExSockaddrs",
    ],
    "iphlpapi.dll": [
        "GetAdaptersAddresses",
        "GetExtendedTcpTable",
        "GetExtendedUdpTable",
    ],
    "ntdll.dll": [
        "NtCreateFile",
        "NtOpenProcess",
        "NtTerminateProcess",
        "NtQuerySystemInformation",
    ]
    }
    found_suspicious = []
    for entry in pe.DIRECTORY_ENTRY_IMPORT:
        dll_name = entry.dll.decode('utf-8').lower()
        if dll_name in suspicious_imports:
            for imp in entry.imports:
                if imp.name:
                    imp_name = imp.name.decode('utf-8')
                    if imp_name in suspicious_imports[dll_name]:
                        found_suspicious.append(f"{dll_name}:{imp_name}")
    return found_suspicious
    

def code_similarity(file_path, similarity_threshold):
    hash1 = ssdeep.hash_from_file(file_path)
    file_hash = calculate_hash(file_path)[1]  # Get SHA-256 hash
    similar_samples = get_similar_samples(file_hash)
    similarities = []
    for sample in similar_samples:
        if 'attributes' in sample and 'ssdeep' in sample['attributes']:
            known_hash = sample['attributes']['ssdeep']
            similarity = ssdeep.compare(hash1, known_hash)
            if similarity >= similarity_threshold:
                similarities.append((sample['id'], similarity))
    return similarities

def analyze_file(file_path, similarity_threshold):
    """Perform basic static analysis on a file."""
    if not os.path.exists(file_path):
        return {"error": "File not found"}

    result = {}
    result['file_name'] = os.path.basename(file_path)
    result['file_size'] = os.path.getsize(file_path)
    result['file_type'] = get_file_type(file_path)
    result['md5'], result['sha256'] = calculate_hash(file_path)

    with open(file_path, 'rb') as f:
        data = f.read()
        result['entropy'] = calculate_entropy(data.decode('latin-1'))

    # Extract strings for additional analysis
    result['strings'] = extract_strings(file_path)

    if result['file_type'].startswith('PE32'):
        result['pe_info'] = analyze_pe(file_path)

    # Simple heuristic to flag potential malware based on entropy and strings
    result['malware_likelihood'] = 0
    if result['entropy'] > 7.2:
        result['malware_likelihood'] += 50
    if 'malware' in result['strings'].lower():
        result['malware_likelihood'] += 50

    if result['malware_likelihood'] > 100:
        result['malware_likelihood'] = 100
    if result['malware_likelihood'] == 0:
        del result['malware_likelihood']

     # Get VirusTotal report
    vt_report = get_virustotal_report(result['sha256'])
    if 'data' in vt_report:
        result['virustotal'] = {
            'positives': vt_report['data']['attributes']['last_analysis_stats']['malicious'],
            'total': sum(vt_report['data']['attributes']['last_analysis_stats'].values()),
            'scan_date': vt_report['data']['attributes']['last_analysis_date'],
            'popular_threat_classification': vt_report['data']['attributes'].get('popular_threat_classification', {}),
            'names': [name for name in vt_report['data']['attributes']['names'] if name],
        }
    else:
        result['virustotal'] = vt_report

    mitre_data = get_mitre_attack_techniques(result['sha256'])
    if 'data' in mitre_data:
        result['mitre_attack'] = mitre_data['data']
    else:
        result['mitre_attack'] = mitre_data
    
    result['yara_matches'] = yara_match(file_path)
    result['code_similarities'] = code_similarity(file_path, similarity_threshold)
   

    return result

    

if __name__ == "__main__":
    # Test the function with a sample file
    sample_file = "/Users/prathameshwalunj/Desktop/6-executable.exe"  # Replace with an actual file path
    analysis_result = analyze_file(sample_file)
    print(analysis_result)
